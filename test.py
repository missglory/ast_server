{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pygments import highlight\n",
    "from pygments.lexers import CppLexer\n",
    "from pygments.token import Keyword, Name, Punctuation, Operator\n",
    "\n",
    "def parse_cpp_code(code):\n",
    "    # Create a C++ lexer\n",
    "    lexer = CppLexer()\n",
    "\n",
    "    # Tokenize the code using the lexer\n",
    "    tokens = lexer.get_tokens(code)\n",
    "\n",
    "    # Initialize variables to store classes, namespaces, and functions\n",
    "    classes = {}\n",
    "    namespaces = {}\n",
    "    functions = {}\n",
    "\n",
    "    # Initialize variables to store the current namespace and class\n",
    "    current_namespace = ''\n",
    "    current_class = ''\n",
    "\n",
    "    # Loop over the tokens and extract classes, namespaces, and functions\n",
    "    for token_type, token_value in tokens:\n",
    "        if token_type is Name.Namespace:\n",
    "            current_namespace = token_value\n",
    "            namespaces[current_namespace] = []\n",
    "            current_class = ''\n",
    "        elif token_type is Keyword and token_value == 'class':\n",
    "            current_class = next(tokens)[1]\n",
    "            classes[current_class] = {'namespace': current_namespace, 'functions': []}\n",
    "        elif token_type is Name.Function:\n",
    "            function_name = token_value\n",
    "            function_args = []\n",
    "\n",
    "            # Loop over the tokens until we find the end of the function definition\n",
    "            for sub_token_type, sub_token_value in tokens:\n",
    "                if sub_token_type is Punctuation and sub_token_value == '(':\n",
    "                    # We've found the start of the argument list\n",
    "                    break\n",
    "            else:\n",
    "                # We didn't find the start of the argument list, so skip this token\n",
    "                continue\n",
    "\n",
    "            # Loop over the tokens in the argument list\n",
    "            for sub_token_type, sub_token_value in tokens:\n",
    "                if sub_token_type is Punctuation and sub_token_value == ')':\n",
    "                    # We've found the end of the argument list\n",
    "                    break\n",
    "                elif sub_token_type is Name:\n",
    "                    # We've found an argument name\n",
    "                    function_args.append(sub_token_value)\n",
    "\n",
    "            # Store the function information in the current class or namespace\n",
    "            if current_class:\n",
    "                classes[current_class]['functions'].append({'name': function_name, 'args': function_args})\n",
    "            else:\n",
    "                namespaces[current_namespace].append({'name': function_name, 'args': function_args})\n",
    "\n",
    "    return classes, namespaces, functions\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "cpp_code=\"\"\"\n",
    "/*\n",
    " * (C) 1999 Lars Knoll (knoll@kde.org)\n",
    " * (C) 2000 Gunnstein Lye (gunnstein@netcom.no)\n",
    " * (C) 2000 Frederik Holljen (frederik.holljen@hig.no)\n",
    " * (C) 2001 Peter Kelly (pmk@post.com)\n",
    " * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Apple Inc. All\n",
    " * rights reserved.\n",
    " * Copyright (C) 2011 Motorola Mobility. All rights reserved.\n",
    " *\n",
    " * This library is free software; you can redistribute it and/or\n",
    " * modify it under the terms of the GNU Library General Public\n",
    " * License as published by the Free Software Foundation; either\n",
    " * version 2 of the License, or (at your option) any later version.\n",
    " *\n",
    " * This library is distributed in the hope that it will be useful,\n",
    " * but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
    " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n",
    " * Library General Public License for more details.\n",
    " *\n",
    " * You should have received a copy of the GNU Library General Public License\n",
    " * along with this library; see the file COPYING.LIB.  If not, write to\n",
    " * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n",
    " * Boston, MA 02110-1301, USA.\n",
    " */\n",
    "\n",
    "#include \"third_party/blink/renderer/core/dom/range.h\"\n",
    "\n",
    "#include \"third_party/blink/renderer/core/display_lock/display_lock_document_state.h\"\n",
    "#include \"third_party/blink/renderer/core/display_lock/display_lock_utilities.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/character_data.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/container_node.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/document_fragment.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/events/event_dispatch_forbidden_scope.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/events/scoped_event_queue.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/node.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/node_traversal.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/node_with_index.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/processing_instruction.h\"\n",
    "#include \"third_party/blink/renderer/core/dom/text.h\"\n",
    "#include \"third_party/blink/renderer/core/editing/editing_utilities.h\"\n",
    "#include \"third_party/blink/renderer/core/editing/ephemeral_range.h\"\n",
    "#include \"third_party/blink/renderer/core/editing/frame_selection.h\"\n",
    "#include \"third_party/blink/renderer/core/editing/iterators/text_iterator.h\"\n",
    "#include \"third_party/blink/renderer/core/editing/selection_template.h\"\n",
    "#include \"third_party/blink/renderer/core/editing/serializers/serialization.h\"\n",
    "#include \"third_party/blink/renderer/core/editing/set_selection_options.h\"\n",
    "#include \"third_party/blink/renderer/core/editing/visible_position.h\"\n",
    "#include \"third_party/blink/renderer/core/editing/visible_units.h\"\n",
    "#include \"third_party/blink/renderer/core/frame/local_dom_window.h\"\n",
    "#include \"third_party/blink/renderer/core/frame/local_frame.h\"\n",
    "#include \"third_party/blink/renderer/core/frame/settings.h\"\n",
    "#include \"third_party/blink/renderer/core/geometry/dom_rect.h\"\n",
    "#include \"third_party/blink/renderer/core/geometry/dom_rect_list.h\"\n",
    "#include \"third_party/blink/renderer/core/highlight/highlight_registry.h\"\n",
    "#include \"third_party/blink/renderer/core/html/html_body_element.h\"\n",
    "#include \"third_party/blink/renderer/core/html/html_element.h\"\n",
    "#include \"third_party/blink/renderer/core/layout/layout_object.h\"\n",
    "#include \"third_party/blink/renderer/core/layout/layout_text.h\"\n",
    "#include \"third_party/blink/renderer/core/layout/layout_text_fragment.h\"\n",
    "#include \"third_party/blink/renderer/core/svg/svg_svg_element.h\"\n",
    "#include \"third_party/blink/renderer/core/trustedtypes/trusted_types_util.h\"\n",
    "#include \"third_party/blink/renderer/platform/bindings/exception_state.h\"\n",
    "#include \"third_party/blink/renderer/platform/heap/garbage_collected.h\"\n",
    "#include \"third_party/blink/renderer/platform/wtf/text/string_builder.h\"\n",
    "#include \"ui/gfx/geometry/quad_f.h\"\n",
    "\n",
    "namespace blink {\n",
    "\n",
    "class RangeUpdateScope {\n",
    "  STACK_ALLOCATED();\n",
    "\n",
    " public:\n",
    "  explicit RangeUpdateScope(Range* range) {\n",
    "    DCHECK(range);\n",
    "    if (++scope_count_ == 1) {\n",
    "      range_ = range;\n",
    "      old_document_ = &range->OwnerDocument();\n",
    "#if DCHECK_IS_ON()\n",
    "      current_range_ = range;\n",
    "    } else {\n",
    "      DCHECK_EQ(current_range_, range);\n",
    "#endif\n",
    "    }\n",
    "  }\n",
    "  RangeUpdateScope(const RangeUpdateScope&) = delete;\n",
    "  RangeUpdateScope& operator=(const RangeUpdateScope&) = delete;\n",
    "\n",
    "  ~RangeUpdateScope() {\n",
    "    DCHECK_GE(scope_count_, 1);\n",
    "    if (--scope_count_ > 0)\n",
    "      return;\n",
    "    Settings* settings = old_document_->GetFrame()\n",
    "                             ? old_document_->GetFrame()->GetSettings()\n",
    "                             : nullptr;\n",
    "    if (!settings ||\n",
    "        !settings->GetDoNotUpdateSelectionOnMutatingSelectionRange()) {\n",
    "      range_->RemoveFromSelectionIfInDifferentRoot(*old_document_);\n",
    "      range_->UpdateSelectionIfAddedToSelection();\n",
    "    }\n",
    "\n",
    "    range_->ScheduleVisualUpdateIfInRegisteredHighlight(\n",
    "        range_->OwnerDocument());\n",
    "    if (*old_document_ != range_->OwnerDocument()) {\n",
    "      range_->ScheduleVisualUpdateIfInRegisteredHighlight(*old_document_);\n",
    "    }\n",
    "#if DCHECK_IS_ON()\n",
    "    current_range_ = nullptr;\n",
    "#endif\n",
    "  }\n",
    "\n",
    " private:\n",
    "  static int scope_count_;\n",
    "#if DCHECK_IS_ON()\n",
    "  // This raw pointer is safe because\n",
    "  //  - s_currentRange has a valid pointer only if RangeUpdateScope instance is\n",
    "  //  live.\n",
    "  //  - RangeUpdateScope is used only in Range member functions.\n",
    "  static Range* current_range_;\n",
    "#endif\n",
    "  Range* range_ = nullptr;\n",
    "  Document* old_document_ = nullptr;\n",
    "\n",
    "};\n",
    "\n",
    "int RangeUpdateScope::scope_count_ = 0;\n",
    "#if DCHECK_IS_ON()\n",
    "Range* RangeUpdateScope::current_range_;\n",
    "#endif\n",
    "\n",
    "Range::Range(Document& owner_document)\n",
    "    : owner_document_(&owner_document),\n",
    "      start_(*owner_document_),\n",
    "      end_(*owner_document_) {\n",
    "  owner_document_->AttachRange(this);\n",
    "}\n",
    "\n",
    "Range* Range::Create(Document& owner_document) {\n",
    "  return MakeGarbageCollected<Range>(owner_document);\n",
    "}\n",
    "\n",
    "Range::Range(Document& owner_document,\n",
    "             Node* start_container,\n",
    "             unsigned start_offset,\n",
    "             Node* end_container,\n",
    "             unsigned end_offset)\n",
    "    : owner_document_(&owner_document),\n",
    "      start_(*owner_document_),\n",
    "      end_(*owner_document_) {\n",
    "  owner_document_->AttachRange(this);\n",
    "\n",
    "  // Simply setting the containers and offsets directly would not do any of the\n",
    "  // checking that setStart and setEnd do, so we call those functions.\n",
    "  setStart(start_container, start_offset);\n",
    "  setEnd(end_container, end_offset);\n",
    "}\n",
    "\n",
    "Range::Range(Document& owner_document,\n",
    "             const Position& start,\n",
    "             const Position& end)\n",
    "    : Range(owner_document,\n",
    "            start.ComputeContainerNode(),\n",
    "            start.ComputeOffsetInContainerNode(),\n",
    "            end.ComputeContainerNode(),\n",
    "            end.ComputeOffsetInContainerNode()) {}\n",
    "\n",
    "void Range::Dispose() {\n",
    "  // A prompt detach from the owning Document helps avoid GC overhead.\n",
    "  owner_document_->DetachRange(this);\n",
    "}\n",
    "\n",
    "bool Range::IsConnected() const {\n",
    "  DCHECK_EQ(start_.IsConnected(), end_.IsConnected());\n",
    "  return start_.IsConnected();\n",
    "}\n",
    "\n",
    "void Range::SetDocument(Document& document) {\n",
    "  DCHECK_NE(owner_document_, document);\n",
    "  DCHECK(owner_document_);\n",
    "  owner_document_->DetachRange(this);\n",
    "  owner_document_ = &document;\n",
    "  start_.SetToStartOfNode(document);\n",
    "  end_.SetToStartOfNode(document);\n",
    "  owner_document_->AttachRange(this);\n",
    "}\n",
    "\n",
    "Node* Range::commonAncestorContainer() const {\n",
    "  return commonAncestorContainer(&start_.Container(), &end_.Container());\n",
    "}\n",
    "\n",
    "Node* Range::commonAncestorContainer(const Node* container_a,\n",
    "                                     const Node* container_b) {\n",
    "  if (!container_a || !container_b)\n",
    "    return nullptr;\n",
    "  return container_a->CommonAncestor(*container_b, NodeTraversal::Parent);\n",
    "}\n",
    "\n",
    "void Range::setStart(Node* ref_node,\n",
    "                     unsigned offset,\n",
    "                     ExceptionState& exception_state) {\n",
    "  if (!ref_node) {\n",
    "    // FIXME: Generated bindings code never calls with null, and neither should\n",
    "    // other callers!\n",
    "    exception_state.ThrowTypeError(\"The node provided is null.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  RangeUpdateScope scope(this);\n",
    "  bool did_move_document = false;\n",
    "  if (ref_node->GetDocument() != owner_document_) {\n",
    "    SetDocument(ref_node->GetDocument());\n",
    "    did_move_document = true;\n",
    "  }\n",
    "\n",
    "  Node* child_node = CheckNodeWOffset(ref_node, offset, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  start_.Set(*ref_node, offset, child_node);\n",
    "\n",
    "  if (did_move_document ||\n",
    "      HasDifferentRootContainer(&start_.Container(), &end_.Container()) ||\n",
    "      compareBoundaryPoints(start_, end_, ASSERT_NO_EXCEPTION) > 0)\n",
    "    collapse(true);\n",
    "}\n",
    "\n",
    "void Range::setEnd(Node* ref_node,\n",
    "                   unsigned offset,\n",
    "                   ExceptionState& exception_state) {\n",
    "  if (!ref_node) {\n",
    "    // FIXME: Generated bindings code never calls with null, and neither should\n",
    "    // other callers!\n",
    "    exception_state.ThrowTypeError(\"The node provided is null.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  RangeUpdateScope scope(this);\n",
    "  bool did_move_document = false;\n",
    "  if (ref_node->GetDocument() != owner_document_) {\n",
    "    SetDocument(ref_node->GetDocument());\n",
    "    did_move_document = true;\n",
    "  }\n",
    "\n",
    "  Node* child_node = CheckNodeWOffset(ref_node, offset, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  end_.Set(*ref_node, offset, child_node);\n",
    "\n",
    "  if (did_move_document ||\n",
    "      HasDifferentRootContainer(&start_.Container(), &end_.Container()) ||\n",
    "      compareBoundaryPoints(start_, end_, ASSERT_NO_EXCEPTION) > 0)\n",
    "    collapse(false);\n",
    "}\n",
    "\n",
    "void Range::setStart(const Position& start, ExceptionState& exception_state) {\n",
    "  Position parent_anchored = start.ParentAnchoredEquivalent();\n",
    "  setStart(parent_anchored.ComputeContainerNode(),\n",
    "           parent_anchored.OffsetInContainerNode(), exception_state);\n",
    "}\n",
    "\n",
    "void Range::setEnd(const Position& end, ExceptionState& exception_state) {\n",
    "  Position parent_anchored = end.ParentAnchoredEquivalent();\n",
    "  setEnd(parent_anchored.ComputeContainerNode(),\n",
    "         parent_anchored.OffsetInContainerNode(), exception_state);\n",
    "}\n",
    "\n",
    "void Range::collapse(bool to_start) {\n",
    "  RangeUpdateScope scope(this);\n",
    "  if (to_start)\n",
    "    end_ = start_;\n",
    "  else\n",
    "    start_ = end_;\n",
    "}\n",
    "\n",
    "bool Range::HasSameRoot(const Node& node) const {\n",
    "  if (node.GetDocument() != owner_document_)\n",
    "    return false;\n",
    "  // commonAncestorContainer() is O(depth). We should avoid to call it in common\n",
    "  // cases.\n",
    "  if (node.IsInTreeScope() && start_.Container().IsInTreeScope() &&\n",
    "      &node.GetTreeScope() == &start_.Container().GetTreeScope())\n",
    "    return true;\n",
    "  return node.CommonAncestor(start_.Container(), NodeTraversal::Parent);\n",
    "}\n",
    "\n",
    "bool Range::isPointInRange(Node* ref_node,\n",
    "                           unsigned offset,\n",
    "                           ExceptionState& exception_state) const {\n",
    "  if (!ref_node) {\n",
    "    // FIXME: Generated bindings code never calls with null, and neither should\n",
    "    // other callers!\n",
    "    exception_state.ThrowTypeError(\"The node provided is null.\");\n",
    "    return false;\n",
    "  }\n",
    "  if (!HasSameRoot(*ref_node))\n",
    "    return false;\n",
    "\n",
    "  CheckNodeWOffset(ref_node, offset, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return false;\n",
    "\n",
    "  return compareBoundaryPoints(ref_node, offset, &start_.Container(),\n",
    "                               start_.Offset(), exception_state) >= 0 &&\n",
    "         !exception_state.HadException() &&\n",
    "         compareBoundaryPoints(ref_node, offset, &end_.Container(),\n",
    "                               end_.Offset(), exception_state) <= 0 &&\n",
    "         !exception_state.HadException();\n",
    "}\n",
    "\n",
    "int16_t Range::comparePoint(Node* ref_node,\n",
    "                            unsigned offset,\n",
    "                            ExceptionState& exception_state) const {\n",
    "  // http://developer.mozilla.org/en/docs/DOM:range.comparePoint\n",
    "  // This method returns -1, 0 or 1 depending on if the point described by the\n",
    "  // refNode node and an offset within the node is before, same as, or after the\n",
    "  // range respectively.\n",
    "\n",
    "  if (!HasSameRoot(*ref_node)) {\n",
    "    exception_state.ThrowDOMException(\n",
    "        DOMExceptionCode::kWrongDocumentError,\n",
    "        \"The node provided and the Range are not in the same tree.\");\n",
    "    return 0;\n",
    "  }\n",
    "\n",
    "  CheckNodeWOffset(ref_node, offset, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return 0;\n",
    "\n",
    "  // compare to start, and point comes before\n",
    "  if (compareBoundaryPoints(ref_node, offset, &start_.Container(),\n",
    "                            start_.Offset(), exception_state) < 0)\n",
    "    return -1;\n",
    "\n",
    "  if (exception_state.HadException())\n",
    "    return 0;\n",
    "\n",
    "  // compare to end, and point comes after\n",
    "  if (compareBoundaryPoints(ref_node, offset, &end_.Container(), end_.Offset(),\n",
    "                            exception_state) > 0 &&\n",
    "      !exception_state.HadException())\n",
    "    return 1;\n",
    "\n",
    "  // point is in the middle of this range, or on the boundary points\n",
    "  return 0;\n",
    "}\n",
    "\n",
    "int16_t Range::compareBoundaryPoints(unsigned how,\n",
    "                                     const Range* source_range,\n",
    "                                     ExceptionState& exception_state) const {\n",
    "  if (!(how == kStartToStart || how == kStartToEnd || how == kEndToEnd ||\n",
    "        how == kEndToStart)) {\n",
    "    exception_state.ThrowDOMException(\n",
    "        DOMExceptionCode::kNotSupportedError,\n",
    "        \"The comparison method provided must be \"\n",
    "        \"one of 'START_TO_START', 'START_TO_END', \"\n",
    "        \"'END_TO_END', or 'END_TO_START'.\");\n",
    "    return 0;\n",
    "  }\n",
    "\n",
    "  Node* this_cont = commonAncestorContainer();\n",
    "  Node* source_cont = source_range->commonAncestorContainer();\n",
    "  if (this_cont->GetDocument() != source_cont->GetDocument()) {\n",
    "    exception_state.ThrowDOMException(\n",
    "        DOMExceptionCode::kWrongDocumentError,\n",
    "        \"The source range is in a different document than this range.\");\n",
    "    return 0;\n",
    "  }\n",
    "\n",
    "  Node* this_top = this_cont;\n",
    "  Node* source_top = source_cont;\n",
    "  while (this_top->parentNode())\n",
    "    this_top = this_top->parentNode();\n",
    "  while (source_top->parentNode())\n",
    "    source_top = source_top->parentNode();\n",
    "  if (this_top != source_top) {  // in different DocumentFragments\n",
    "    exception_state.ThrowDOMException(\n",
    "        DOMExceptionCode::kWrongDocumentError,\n",
    "        \"The source range is in a different document than this range.\");\n",
    "    return 0;\n",
    "  }\n",
    "\n",
    "  switch (how) {\n",
    "    case kStartToStart:\n",
    "      return compareBoundaryPoints(start_, source_range->start_,\n",
    "                                   exception_state);\n",
    "    case kStartToEnd:\n",
    "      return compareBoundaryPoints(end_, source_range->start_, exception_state);\n",
    "    case kEndToEnd:\n",
    "      return compareBoundaryPoints(end_, source_range->end_, exception_state);\n",
    "    case kEndToStart:\n",
    "      return compareBoundaryPoints(start_, source_range->end_, exception_state);\n",
    "  }\n",
    "\n",
    "  NOTREACHED();\n",
    "  return 0;\n",
    "}\n",
    "\n",
    "int16_t Range::compareBoundaryPoints(Node* container_a,\n",
    "                                     unsigned offset_a,\n",
    "                                     Node* container_b,\n",
    "                                     unsigned offset_b,\n",
    "                                     ExceptionState& exception_state) {\n",
    "  bool disconnected = false;\n",
    "  int16_t result = ComparePositionsInDOMTree(container_a, offset_a, container_b,\n",
    "                                             offset_b, &disconnected);\n",
    "  if (disconnected) {\n",
    "    exception_state.ThrowDOMException(\n",
    "        DOMExceptionCode::kWrongDocumentError,\n",
    "        \"The two ranges are in separate documents.\");\n",
    "    return 0;\n",
    "  }\n",
    "  return result;\n",
    "}\n",
    "\n",
    "int16_t Range::compareBoundaryPoints(const RangeBoundaryPoint& boundary_a,\n",
    "                                     const RangeBoundaryPoint& boundary_b,\n",
    "                                     ExceptionState& exception_state) {\n",
    "  return compareBoundaryPoints(&boundary_a.Container(), boundary_a.Offset(),\n",
    "                               &boundary_b.Container(), boundary_b.Offset(),\n",
    "                               exception_state);\n",
    "}\n",
    "\n",
    "bool Range::BoundaryPointsValid() const {\n",
    "  DummyExceptionStateForTesting exception_state;\n",
    "  return compareBoundaryPoints(start_, end_, exception_state) <= 0 &&\n",
    "         !exception_state.HadException();\n",
    "}\n",
    "\n",
    "void Range::deleteContents(ExceptionState& exception_state) {\n",
    "  DCHECK(BoundaryPointsValid());\n",
    "\n",
    "  {\n",
    "    EventQueueScope event_queue_scope;\n",
    "    ProcessContents(kDeleteContents, exception_state);\n",
    "  }\n",
    "}\n",
    "\n",
    "bool Range::intersectsNode(Node* ref_node, ExceptionState& exception_state) {\n",
    "  // http://developer.mozilla.org/en/docs/DOM:range.intersectsNode\n",
    "  // Returns a bool if the node intersects the range.\n",
    "  if (!ref_node) {\n",
    "    // FIXME: Generated bindings code never calls with null, and neither should\n",
    "    // other callers!\n",
    "    exception_state.ThrowTypeError(\"The node provided is null.\");\n",
    "    return false;\n",
    "  }\n",
    "  if (!HasSameRoot(*ref_node))\n",
    "    return false;\n",
    "\n",
    "  ContainerNode* parent_node = ref_node->parentNode();\n",
    "  if (!parent_node)\n",
    "    return true;\n",
    "\n",
    "  int node_index = ref_node->NodeIndex();\n",
    "  return Position(parent_node, node_index) < end_.ToPosition() &&\n",
    "         Position(parent_node, node_index + 1) > start_.ToPosition();\n",
    "}\n",
    "\n",
    "static inline Node* HighestAncestorUnderCommonRoot(Node* node,\n",
    "                                                   Node* common_root) {\n",
    "  if (node == common_root)\n",
    "    return nullptr;\n",
    "\n",
    "  DCHECK(common_root->contains(node));\n",
    "\n",
    "  while (node->parentNode() != common_root)\n",
    "    node = node->parentNode();\n",
    "\n",
    "  return node;\n",
    "}\n",
    "\n",
    "static inline Node* ChildOfCommonRootBeforeOffset(Node* container,\n",
    "                                                  unsigned offset,\n",
    "                                                  Node* common_root) {\n",
    "  DCHECK(container);\n",
    "  DCHECK(common_root);\n",
    "\n",
    "  if (!common_root->contains(container))\n",
    "    return nullptr;\n",
    "\n",
    "  if (container == common_root) {\n",
    "    container = container->firstChild();\n",
    "    for (unsigned i = 0; container && i < offset; i++)\n",
    "      container = container->nextSibling();\n",
    "  } else {\n",
    "    while (container->parentNode() != common_root)\n",
    "      container = container->parentNode();\n",
    "  }\n",
    "\n",
    "  return container;\n",
    "}\n",
    "\n",
    "DocumentFragment* Range::ProcessContents(ActionType action,\n",
    "                                         ExceptionState& exception_state) {\n",
    "  DocumentFragment* fragment = nullptr;\n",
    "  if (action == kExtractContents || action == kCloneContents)\n",
    "    fragment = DocumentFragment::Create(*owner_document_.Get());\n",
    "\n",
    "  if (collapsed())\n",
    "    return fragment;\n",
    "\n",
    "  Node* common_root = commonAncestorContainer();\n",
    "  DCHECK(common_root);\n",
    "\n",
    "  if (start_.Container() == end_.Container()) {\n",
    "    ProcessContentsBetweenOffsets(action, fragment, &start_.Container(),\n",
    "                                  start_.Offset(), end_.Offset(),\n",
    "                                  exception_state);\n",
    "    return fragment;\n",
    "  }\n",
    "\n",
    "  // Since mutation observers can modify the range during the process, the\n",
    "  // boundary points need to be saved.\n",
    "  const RangeBoundaryPoint original_start(start_);\n",
    "  const RangeBoundaryPoint original_end(end_);\n",
    "\n",
    "  // what is the highest node that partially selects the start / end of the\n",
    "  // range?\n",
    "  Node* partial_start =\n",
    "      HighestAncestorUnderCommonRoot(&original_start.Container(), common_root);\n",
    "  Node* partial_end =\n",
    "      HighestAncestorUnderCommonRoot(&original_end.Container(), common_root);\n",
    "\n",
    "  // Start and end containers are different.\n",
    "  // There are three possibilities here:\n",
    "  // 1. Start container == commonRoot (End container must be a descendant)\n",
    "  // 2. End container == commonRoot (Start container must be a descendant)\n",
    "  // 3. Neither is commonRoot, they are both descendants\n",
    "  //\n",
    "  // In case 3, we grab everything after the start (up until a direct child\n",
    "  // of commonRoot) into leftContents, and everything before the end (up until\n",
    "  // a direct child of commonRoot) into rightContents. Then we process all\n",
    "  // commonRoot children between leftContents and rightContents\n",
    "  //\n",
    "  // In case 1 or 2, we skip either processing of leftContents or rightContents,\n",
    "  // in which case the last lot of nodes either goes from the first or last\n",
    "  // child of commonRoot.\n",
    "  //\n",
    "  // These are deleted, cloned, or extracted (i.e. both) depending on action.\n",
    "\n",
    "  // Note that we are verifying that our common root hierarchy is still intact\n",
    "  // after any DOM mutation event, at various stages below. See webkit bug\n",
    "  // 60350.\n",
    "\n",
    "  Node* left_contents = nullptr;\n",
    "  if (original_start.Container() != common_root &&\n",
    "      common_root->contains(&original_start.Container())) {\n",
    "    left_contents = ProcessContentsBetweenOffsets(\n",
    "        action, nullptr, &original_start.Container(), original_start.Offset(),\n",
    "        AbstractRange::LengthOfContents(&original_start.Container()),\n",
    "        exception_state);\n",
    "    left_contents = ProcessAncestorsAndTheirSiblings(\n",
    "        action, &original_start.Container(), kProcessContentsForward,\n",
    "        left_contents, common_root, exception_state);\n",
    "  }\n",
    "\n",
    "  Node* right_contents = nullptr;\n",
    "  if (end_.Container() != common_root &&\n",
    "      common_root->contains(&original_end.Container())) {\n",
    "    right_contents = ProcessContentsBetweenOffsets(\n",
    "        action, nullptr, &original_end.Container(), 0, original_end.Offset(),\n",
    "        exception_state);\n",
    "    right_contents = ProcessAncestorsAndTheirSiblings(\n",
    "        action, &original_end.Container(), kProcessContentsBackward,\n",
    "        right_contents, common_root, exception_state);\n",
    "  }\n",
    "\n",
    "  // delete all children of commonRoot between the start and end container\n",
    "  Node* process_start = ChildOfCommonRootBeforeOffset(\n",
    "      &original_start.Container(), original_start.Offset(), common_root);\n",
    "  // process_start contains nodes before start_.\n",
    "  if (process_start && original_start.Container() != common_root)\n",
    "    process_start = process_start->nextSibling();\n",
    "  Node* process_end = ChildOfCommonRootBeforeOffset(\n",
    "      &original_end.Container(), original_end.Offset(), common_root);\n",
    "\n",
    "  // Collapse the range, making sure that the result is not within a node that\n",
    "  // was partially selected.\n",
    "  if (action == kExtractContents || action == kDeleteContents) {\n",
    "    if (partial_start && common_root->contains(partial_start)) {\n",
    "      // FIXME: We should not continue if we have an earlier error.\n",
    "      exception_state.ClearException();\n",
    "      setStart(partial_start->parentNode(), partial_start->NodeIndex() + 1,\n",
    "               exception_state);\n",
    "    } else if (partial_end && common_root->contains(partial_end)) {\n",
    "      // FIXME: We should not continue if we have an earlier error.\n",
    "      exception_state.ClearException();\n",
    "      setStart(partial_end->parentNode(), partial_end->NodeIndex(),\n",
    "               exception_state);\n",
    "    }\n",
    "    if (exception_state.HadException())\n",
    "      return nullptr;\n",
    "    end_ = start_;\n",
    "  }\n",
    "\n",
    "  // Now add leftContents, stuff in between, and rightContents to the fragment\n",
    "  // (or just delete the stuff in between)\n",
    "\n",
    "  if ((action == kExtractContents || action == kCloneContents) && left_contents)\n",
    "    fragment->AppendChild(left_contents, exception_state);\n",
    "\n",
    "  if (process_start) {\n",
    "    NodeVector nodes;\n",
    "    for (Node* n = process_start; n && n != process_end; n = n->nextSibling())\n",
    "      nodes.push_back(n);\n",
    "    ProcessNodes(action, nodes, common_root, fragment, exception_state);\n",
    "  }\n",
    "\n",
    "  if ((action == kExtractContents || action == kCloneContents) &&\n",
    "      right_contents)\n",
    "    fragment->AppendChild(right_contents, exception_state);\n",
    "\n",
    "  return fragment;\n",
    "}\n",
    "\n",
    "static inline void DeleteCharacterData(CharacterData* data,\n",
    "                                       unsigned start_offset,\n",
    "                                       unsigned end_offset,\n",
    "                                       ExceptionState& exception_state) {\n",
    "  if (data->length() - end_offset)\n",
    "    data->deleteData(end_offset, data->length() - end_offset, exception_state);\n",
    "  if (start_offset)\n",
    "    data->deleteData(0, start_offset, exception_state);\n",
    "}\n",
    "\n",
    "Node* Range::ProcessContentsBetweenOffsets(ActionType action,\n",
    "                                           DocumentFragment* fragment,\n",
    "                                           Node* container,\n",
    "                                           unsigned start_offset,\n",
    "                                           unsigned end_offset,\n",
    "                                           ExceptionState& exception_state) {\n",
    "  DCHECK(container);\n",
    "  DCHECK_LE(start_offset, end_offset);\n",
    "\n",
    "  // This switch statement must be consistent with that of\n",
    "  // lengthOfContents.\n",
    "  Node* result = nullptr;\n",
    "  switch (container->getNodeType()) {\n",
    "    case Node::kTextNode:\n",
    "    case Node::kCdataSectionNode:\n",
    "    case Node::kCommentNode:\n",
    "    case Node::kProcessingInstructionNode:\n",
    "      end_offset = std::min(end_offset, To<CharacterData>(container)->length());\n",
    "      if (action == kExtractContents || action == kCloneContents) {\n",
    "        CharacterData* c =\n",
    "            static_cast<CharacterData*>(container->cloneNode(true));\n",
    "        DeleteCharacterData(c, start_offset, end_offset, exception_state);\n",
    "        if (fragment) {\n",
    "          result = fragment;\n",
    "          result->appendChild(c, exception_state);\n",
    "        } else {\n",
    "          result = c;\n",
    "        }\n",
    "      }\n",
    "      if (action == kExtractContents || action == kDeleteContents)\n",
    "        To<CharacterData>(container)->deleteData(\n",
    "            start_offset, end_offset - start_offset, exception_state);\n",
    "      break;\n",
    "    case Node::kElementNode:\n",
    "    case Node::kAttributeNode:\n",
    "    case Node::kDocumentNode:\n",
    "    case Node::kDocumentTypeNode:\n",
    "    case Node::kDocumentFragmentNode:\n",
    "      // FIXME: Should we assert that some nodes never appear here?\n",
    "      if (action == kExtractContents || action == kCloneContents) {\n",
    "        if (fragment)\n",
    "          result = fragment;\n",
    "        else\n",
    "          result = container->cloneNode(false);\n",
    "      }\n",
    "\n",
    "      Node* n = container->firstChild();\n",
    "      NodeVector nodes;\n",
    "      for (unsigned i = start_offset; n && i; i--)\n",
    "        n = n->nextSibling();\n",
    "      for (unsigned i = start_offset; n && i < end_offset;\n",
    "           i++, n = n->nextSibling())\n",
    "        nodes.push_back(n);\n",
    "\n",
    "      ProcessNodes(action, nodes, container, result, exception_state);\n",
    "      break;\n",
    "  }\n",
    "\n",
    "  return result;\n",
    "}\n",
    "\n",
    "void Range::ProcessNodes(ActionType action,\n",
    "                         NodeVector& nodes,\n",
    "                         Node* old_container,\n",
    "                         Node* new_container,\n",
    "                         ExceptionState& exception_state) {\n",
    "  for (auto& node : nodes) {\n",
    "    switch (action) {\n",
    "      case kDeleteContents:\n",
    "        old_container->removeChild(node.Get(), exception_state);\n",
    "        break;\n",
    "      case kExtractContents:\n",
    "        new_container->appendChild(\n",
    "            node.Release(), exception_state);  // Will remove n from its parent.\n",
    "        break;\n",
    "      case kCloneContents:\n",
    "        new_container->appendChild(node->cloneNode(true), exception_state);\n",
    "        break;\n",
    "    }\n",
    "  }\n",
    "}\n",
    "\n",
    "Node* Range::ProcessAncestorsAndTheirSiblings(\n",
    "    ActionType action,\n",
    "    Node* container,\n",
    "    ContentsProcessDirection direction,\n",
    "    Node* cloned_container,\n",
    "    Node* common_root,\n",
    "    ExceptionState& exception_state) {\n",
    "  NodeVector ancestors;\n",
    "  for (Node& runner : NodeTraversal::AncestorsOf(*container)) {\n",
    "    if (runner == common_root)\n",
    "      break;\n",
    "    ancestors.push_back(runner);\n",
    "  }\n",
    "\n",
    "  Node* first_child_in_ancestor_to_process =\n",
    "      direction == kProcessContentsForward ? container->nextSibling()\n",
    "                                           : container->previousSibling();\n",
    "  for (const auto& ancestor : ancestors) {\n",
    "    if (action == kExtractContents || action == kCloneContents) {\n",
    "      // Might have been removed already during mutation event.\n",
    "      if (Node* cloned_ancestor = ancestor->cloneNode(false)) {\n",
    "        cloned_ancestor->appendChild(cloned_container, exception_state);\n",
    "        cloned_container = cloned_ancestor;\n",
    "      }\n",
    "    }\n",
    "\n",
    "    // Copy siblings of an ancestor of start/end containers\n",
    "    // FIXME: This assertion may fail if DOM is modified during mutation event\n",
    "    // FIXME: Share code with Range::processNodes\n",
    "    DCHECK(!first_child_in_ancestor_to_process ||\n",
    "           first_child_in_ancestor_to_process->parentNode() == ancestor);\n",
    "\n",
    "    NodeVector nodes;\n",
    "    for (Node* child = first_child_in_ancestor_to_process; child;\n",
    "         child = (direction == kProcessContentsForward)\n",
    "                     ? child->nextSibling()\n",
    "                     : child->previousSibling())\n",
    "      nodes.push_back(child);\n",
    "\n",
    "    for (const auto& node : nodes) {\n",
    "      Node* child = node.Get();\n",
    "      switch (action) {\n",
    "        case kDeleteContents:\n",
    "          // Prior call of ancestor->removeChild() may cause a tree change due\n",
    "          // to DOMSubtreeModified event.  Therefore, we need to make sure\n",
    "          // |ancestor| is still |child|'s parent.\n",
    "          if (ancestor == child->parentNode())\n",
    "            ancestor->removeChild(child, exception_state);\n",
    "          break;\n",
    "        case kExtractContents:  // will remove child from ancestor\n",
    "          if (direction == kProcessContentsForward)\n",
    "            cloned_container->appendChild(child, exception_state);\n",
    "          else\n",
    "            cloned_container->insertBefore(\n",
    "                child, cloned_container->firstChild(), exception_state);\n",
    "          break;\n",
    "        case kCloneContents:\n",
    "          if (direction == kProcessContentsForward)\n",
    "            cloned_container->appendChild(child->cloneNode(true),\n",
    "                                          exception_state);\n",
    "          else\n",
    "            cloned_container->insertBefore(child->cloneNode(true),\n",
    "                                           cloned_container->firstChild(),\n",
    "                                           exception_state);\n",
    "          break;\n",
    "      }\n",
    "    }\n",
    "    first_child_in_ancestor_to_process = direction == kProcessContentsForward\n",
    "                                             ? ancestor->nextSibling()\n",
    "                                             : ancestor->previousSibling();\n",
    "  }\n",
    "\n",
    "  return cloned_container;\n",
    "}\n",
    "\n",
    "DocumentFragment* Range::extractContents(ExceptionState& exception_state) {\n",
    "  CheckExtractPrecondition(exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return nullptr;\n",
    "\n",
    "  EventQueueScope scope;\n",
    "  DocumentFragment* fragment =\n",
    "      ProcessContents(kExtractContents, exception_state);\n",
    "  // |extractContents| has extended attributes [NewObject, DoNotTestNewObject],\n",
    "  // so it's better to have a test that exercises the following condition:\n",
    "  //\n",
    "  //   !fragment || DOMDataStore::GetWrapper(fragment, isolate).IsEmpty()\n",
    "  //\n",
    "  // however, there is no access to |isolate| so far.  So, we simply omit the\n",
    "  // test so far.\n",
    "  return fragment;\n",
    "}\n",
    "\n",
    "DocumentFragment* Range::cloneContents(ExceptionState& exception_state) {\n",
    "  return ProcessContents(kCloneContents, exception_state);\n",
    "}\n",
    "\n",
    "// https://dom.spec.whatwg.org/#concept-range-insert\n",
    "void Range::insertNode(Node* new_node, ExceptionState& exception_state) {\n",
    "  if (!new_node) {\n",
    "    // FIXME: Generated bindings code never calls with null, and neither should\n",
    "    // other callers!\n",
    "    exception_state.ThrowTypeError(\"The node provided is null.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  // 1. If range’s start node is a ProcessingInstruction or Comment node, is a\n",
    "  // Text node whose parent is null, or is node, then throw a\n",
    "  // HierarchyRequestError.\n",
    "  Node& start_node = start_.Container();\n",
    "  if (start_node.getNodeType() == Node::kProcessingInstructionNode ||\n",
    "      start_node.getNodeType() == Node::kCommentNode) {\n",
    "    exception_state.ThrowDOMException(\n",
    "        DOMExceptionCode::kHierarchyRequestError,\n",
    "        \"Nodes of type '\" + new_node->nodeName() +\n",
    "            \"' may not be inserted inside nodes of type '\" +\n",
    "            start_node.nodeName() + \"'.\");\n",
    "    return;\n",
    "  }\n",
    "  const bool start_is_text = start_node.IsTextNode();\n",
    "  if (start_is_text && !start_node.parentNode()) {\n",
    "    exception_state.ThrowDOMException(DOMExceptionCode::kHierarchyRequestError,\n",
    "                                      \"This operation would split a text node, \"\n",
    "                                      \"but there's no parent into which to \"\n",
    "                                      \"insert.\");\n",
    "    return;\n",
    "  }\n",
    "  if (start_node == new_node) {\n",
    "    exception_state.ThrowDOMException(\n",
    "        DOMExceptionCode::kHierarchyRequestError,\n",
    "        \"Unable to insert a node into a Range starting from the node itself.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  // According to the specification, the following condition is checked in the\n",
    "  // step 6. However our EnsurePreInsertionValidity() supports only\n",
    "  // ContainerNode parent.\n",
    "  if (start_node.IsAttributeNode()) {\n",
    "    exception_state.ThrowDOMException(\n",
    "        DOMExceptionCode::kHierarchyRequestError,\n",
    "        \"Nodes of type '\" + new_node->nodeName() +\n",
    "            \"' may not be inserted inside nodes of type 'Attr'.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  // 2. Let referenceNode be null.\n",
    "  Node* reference_node = nullptr;\n",
    "  // 3. If range’s start node is a Text node, set referenceNode to that Text\n",
    "  // node.\n",
    "  // 4. Otherwise, set referenceNode to the child of start node whose index is\n",
    "  // start offset, and null if there is no such child.\n",
    "  if (start_is_text)\n",
    "    reference_node = &start_node;\n",
    "  else\n",
    "    reference_node = NodeTraversal::ChildAt(start_node, start_.Offset());\n",
    "\n",
    "  // 5. Let parent be range’s start node if referenceNode is null, and\n",
    "  // referenceNode’s parent otherwise.\n",
    "  ContainerNode& parent = reference_node ? *reference_node->parentNode()\n",
    "                                         : To<ContainerNode>(start_node);\n",
    "\n",
    "  // 6. Ensure pre-insertion validity of node into parent before referenceNode.\n",
    "  if (!parent.EnsurePreInsertionValidity(*new_node, reference_node, nullptr,\n",
    "                                         exception_state))\n",
    "    return;\n",
    "\n",
    "  EventQueueScope scope;\n",
    "  // 7. If range's start node is a Text node, set referenceNode to the result of\n",
    "  // splitting it with offset range’s start offset.\n",
    "  if (start_is_text) {\n",
    "    reference_node =\n",
    "        To<Text>(start_node).splitText(start_.Offset(), exception_state);\n",
    "    if (exception_state.HadException())\n",
    "      return;\n",
    "  }\n",
    "\n",
    "  // 8. If node is referenceNode, set referenceNode to its next sibling.\n",
    "  if (new_node == reference_node)\n",
    "    reference_node = reference_node->nextSibling();\n",
    "\n",
    "  // 9. If node's parent is not null, remove node from its parent.\n",
    "  if (new_node->parentNode()) {\n",
    "    new_node->remove(exception_state);\n",
    "    if (exception_state.HadException())\n",
    "      return;\n",
    "  }\n",
    "\n",
    "  // 10. Let newOffset be parent's length if referenceNode is null, and\n",
    "  // referenceNode's index otherwise.\n",
    "  unsigned new_offset = reference_node\n",
    "                            ? reference_node->NodeIndex()\n",
    "                            : AbstractRange::LengthOfContents(&parent);\n",
    "\n",
    "  // 11. Increase newOffset by node's length if node is a DocumentFragment node,\n",
    "  // and one otherwise.\n",
    "  new_offset += new_node->IsDocumentFragment()\n",
    "                    ? AbstractRange::LengthOfContents(new_node)\n",
    "                    : 1;\n",
    "\n",
    "  // 12. Pre-insert node into parent before referenceNode.\n",
    "  parent.insertBefore(new_node, reference_node, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  // 13. If range's start and end are the same, set range's end to (parent,\n",
    "  // newOffset).\n",
    "  if (start_ == end_)\n",
    "    setEnd(&parent, new_offset, exception_state);\n",
    "}\n",
    "\n",
    "String Range::toString() const {\n",
    "  StringBuilder builder;\n",
    "\n",
    "  Node* past_last = PastLastNode();\n",
    "  for (Node* n = FirstNode(); n != past_last; n = NodeTraversal::Next(*n)) {\n",
    "    Node::NodeType type = n->getNodeType();\n",
    "    if (type == Node::kTextNode || type == Node::kCdataSectionNode) {\n",
    "      String data = To<CharacterData>(n)->data();\n",
    "      unsigned length = data.length();\n",
    "      unsigned start =\n",
    "          (n == start_.Container()) ? std::min(start_.Offset(), length) : 0;\n",
    "      unsigned end = (n == end_.Container())\n",
    "                         ? std::min(std::max(start, end_.Offset()), length)\n",
    "                         : length;\n",
    "      builder.Append(data, start, end - start);\n",
    "    }\n",
    "  }\n",
    "\n",
    "  return builder.ReleaseString();\n",
    "}\n",
    "\n",
    "String Range::GetText() const {\n",
    "  DCHECK(!owner_document_->NeedsLayoutTreeUpdate());\n",
    "  return PlainText(EphemeralRange(this),\n",
    "                   TextIteratorBehavior::Builder()\n",
    "                       .SetEmitsObjectReplacementCharacter(true)\n",
    "                       .Build());\n",
    "}\n",
    "\n",
    "DocumentFragment* Range::createContextualFragment(\n",
    "    const String& markup,\n",
    "    ExceptionState& exception_state) {\n",
    "  // Algorithm:\n",
    "  // http://domparsing.spec.whatwg.org/#extensions-to-the-range-interface\n",
    "\n",
    "  DCHECK(!markup.IsNull());\n",
    "\n",
    "  Node* node = &start_.Container();\n",
    "\n",
    "  // Step 1.\n",
    "  Element* element;\n",
    "  if (!start_.Offset() &&\n",
    "      (node->IsDocumentNode() || node->IsDocumentFragment()))\n",
    "    element = nullptr;\n",
    "  else if (auto* node_element = DynamicTo<Element>(node))\n",
    "    element = node_element;\n",
    "  else\n",
    "    element = node->parentElement();\n",
    "\n",
    "  // Step 2.\n",
    "  if (!element || IsA<HTMLHtmlElement>(element)) {\n",
    "    Document& document = node->GetDocument();\n",
    "\n",
    "    if (document.IsSVGDocument()) {\n",
    "      element = document.documentElement();\n",
    "      if (!element)\n",
    "        element = MakeGarbageCollected<SVGSVGElement>(document);\n",
    "    } else {\n",
    "      // Optimization over spec: try to reuse the existing <body> element, if it\n",
    "      // is available.\n",
    "      element = document.body();\n",
    "      if (!element)\n",
    "        element = MakeGarbageCollected<HTMLBodyElement>(document);\n",
    "    }\n",
    "  }\n",
    "\n",
    "  // Steps 3, 4, 5.\n",
    "  return blink::CreateContextualFragment(\n",
    "      markup, element, kAllowScriptingContentAndDoNotMarkAlreadyStarted,\n",
    "      exception_state);\n",
    "}\n",
    "\n",
    "void Range::detach() {\n",
    "  // This is now a no-op as per the DOM specification.\n",
    "}\n",
    "\n",
    "Node* Range::CheckNodeWOffset(Node* n,\n",
    "                              unsigned offset,\n",
    "                              ExceptionState& exception_state) {\n",
    "  switch (n->getNodeType()) {\n",
    "    case Node::kDocumentTypeNode:\n",
    "      exception_state.ThrowDOMException(\n",
    "          DOMExceptionCode::kInvalidNodeTypeError,\n",
    "          \"The node provided is of type '\" + n->nodeName() + \"'.\");\n",
    "      return nullptr;\n",
    "    case Node::kCdataSectionNode:\n",
    "    case Node::kCommentNode:\n",
    "    case Node::kTextNode:\n",
    "      if (offset > To<CharacterData>(n)->length()) {\n",
    "        exception_state.ThrowDOMException(\n",
    "            DOMExceptionCode::kIndexSizeError,\n",
    "            \"The offset \" + String::Number(offset) +\n",
    "                \" is larger than the node's length (\" +\n",
    "                String::Number(To<CharacterData>(n)->length()) + \").\");\n",
    "      } else if (offset >\n",
    "                 static_cast<unsigned>(std::numeric_limits<int>::max())) {\n",
    "        exception_state.ThrowDOMException(\n",
    "            DOMExceptionCode::kIndexSizeError,\n",
    "            \"The offset \" + String::Number(offset) + \" is invalid.\");\n",
    "      }\n",
    "      return nullptr;\n",
    "    case Node::kProcessingInstructionNode:\n",
    "      if (offset > To<ProcessingInstruction>(n)->data().length()) {\n",
    "        exception_state.ThrowDOMException(\n",
    "            DOMExceptionCode::kIndexSizeError,\n",
    "            \"The offset \" + String::Number(offset) +\n",
    "                \" is larger than the node's length (\" +\n",
    "                String::Number(To<ProcessingInstruction>(n)->data().length()) +\n",
    "                \").\");\n",
    "      } else if (offset >\n",
    "                 static_cast<unsigned>(std::numeric_limits<int>::max())) {\n",
    "        exception_state.ThrowDOMException(\n",
    "            DOMExceptionCode::kIndexSizeError,\n",
    "            \"The offset \" + String::Number(offset) + \" is invalid.\");\n",
    "      }\n",
    "      return nullptr;\n",
    "    case Node::kAttributeNode:\n",
    "    case Node::kDocumentFragmentNode:\n",
    "    case Node::kDocumentNode:\n",
    "    case Node::kElementNode: {\n",
    "      if (!offset)\n",
    "        return nullptr;\n",
    "      if (offset > static_cast<unsigned>(std::numeric_limits<int>::max())) {\n",
    "        exception_state.ThrowDOMException(\n",
    "            DOMExceptionCode::kIndexSizeError,\n",
    "            \"The offset \" + String::Number(offset) + \" is invalid.\");\n",
    "        return nullptr;\n",
    "      }\n",
    "      Node* child_before = NodeTraversal::ChildAt(*n, offset - 1);\n",
    "      if (!child_before) {\n",
    "        exception_state.ThrowDOMException(\n",
    "            DOMExceptionCode::kIndexSizeError,\n",
    "            \"There is no child at offset \" + String::Number(offset) + \".\");\n",
    "      }\n",
    "      return child_before;\n",
    "    }\n",
    "  }\n",
    "  NOTREACHED();\n",
    "  return nullptr;\n",
    "}\n",
    "\n",
    "void Range::CheckNodeBA(Node* n, ExceptionState& exception_state) const {\n",
    "  if (!n) {\n",
    "    // FIXME: Generated bindings code never calls with null, and neither should\n",
    "    // other callers!\n",
    "    exception_state.ThrowTypeError(\"The node provided is null.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  // InvalidNodeTypeError: Raised if the root container of refNode is not an\n",
    "  // Attr, Document, DocumentFragment or ShadowRoot node, or part of a SVG\n",
    "  // shadow DOM tree, or if refNode is a Document, DocumentFragment, ShadowRoot,\n",
    "  // Attr, Entity, or Notation node.\n",
    "\n",
    "  if (!n->parentNode()) {\n",
    "    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidNodeTypeError,\n",
    "                                      \"the given Node has no parent.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  switch (n->getNodeType()) {\n",
    "    case Node::kAttributeNode:\n",
    "    case Node::kDocumentFragmentNode:\n",
    "    case Node::kDocumentNode:\n",
    "      exception_state.ThrowDOMException(\n",
    "          DOMExceptionCode::kInvalidNodeTypeError,\n",
    "          \"The node provided is of type '\" + n->nodeName() + \"'.\");\n",
    "      return;\n",
    "    case Node::kCdataSectionNode:\n",
    "    case Node::kCommentNode:\n",
    "    case Node::kDocumentTypeNode:\n",
    "    case Node::kElementNode:\n",
    "    case Node::kProcessingInstructionNode:\n",
    "    case Node::kTextNode:\n",
    "      break;\n",
    "  }\n",
    "\n",
    "  Node* root = n;\n",
    "  while (ContainerNode* parent = root->parentNode())\n",
    "    root = parent;\n",
    "\n",
    "  switch (root->getNodeType()) {\n",
    "    case Node::kAttributeNode:\n",
    "    case Node::kDocumentNode:\n",
    "    case Node::kDocumentFragmentNode:\n",
    "    case Node::kElementNode:\n",
    "      break;\n",
    "    case Node::kCdataSectionNode:\n",
    "    case Node::kCommentNode:\n",
    "    case Node::kDocumentTypeNode:\n",
    "    case Node::kProcessingInstructionNode:\n",
    "    case Node::kTextNode:\n",
    "      exception_state.ThrowDOMException(\n",
    "          DOMExceptionCode::kInvalidNodeTypeError,\n",
    "          \"The node provided is of type '\" + n->nodeName() + \"'.\");\n",
    "      return;\n",
    "  }\n",
    "}\n",
    "\n",
    "Range* Range::cloneRange() const {\n",
    "  return MakeGarbageCollected<Range>(*owner_document_.Get(),\n",
    "                                     &start_.Container(), start_.Offset(),\n",
    "                                     &end_.Container(), end_.Offset());\n",
    "}\n",
    "\n",
    "void Range::setStartAfter(Node* ref_node, ExceptionState& exception_state) {\n",
    "  CheckNodeBA(ref_node, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  setStart(ref_node->parentNode(), ref_node->NodeIndex() + 1, exception_state);\n",
    "}\n",
    "\n",
    "void Range::setEndBefore(Node* ref_node, ExceptionState& exception_state) {\n",
    "  CheckNodeBA(ref_node, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  setEnd(ref_node->parentNode(), ref_node->NodeIndex(), exception_state);\n",
    "}\n",
    "\n",
    "void Range::setEndAfter(Node* ref_node, ExceptionState& exception_state) {\n",
    "  CheckNodeBA(ref_node, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  setEnd(ref_node->parentNode(), ref_node->NodeIndex() + 1, exception_state);\n",
    "}\n",
    "\n",
    "void Range::selectNode(Node* ref_node, ExceptionState& exception_state) {\n",
    "  if (!ref_node) {\n",
    "    // FIXME: Generated bindings code never calls with null, and neither should\n",
    "    // other callers!\n",
    "    exception_state.ThrowTypeError(\"The node provided is null.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  if (!ref_node->parentNode()) {\n",
    "    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidNodeTypeError,\n",
    "                                      \"the given Node has no parent.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  switch (ref_node->getNodeType()) {\n",
    "    case Node::kCdataSectionNode:\n",
    "    case Node::kCommentNode:\n",
    "    case Node::kDocumentTypeNode:\n",
    "    case Node::kElementNode:\n",
    "    case Node::kProcessingInstructionNode:\n",
    "    case Node::kTextNode:\n",
    "      break;\n",
    "    case Node::kAttributeNode:\n",
    "    case Node::kDocumentFragmentNode:\n",
    "    case Node::kDocumentNode:\n",
    "      exception_state.ThrowDOMException(\n",
    "          DOMExceptionCode::kInvalidNodeTypeError,\n",
    "          \"The node provided is of type '\" + ref_node->nodeName() + \"'.\");\n",
    "      return;\n",
    "  }\n",
    "\n",
    "  RangeUpdateScope scope(this);\n",
    "  setStartBefore(ref_node);\n",
    "  setEndAfter(ref_node);\n",
    "}\n",
    "\n",
    "void Range::selectNodeContents(Node* ref_node,\n",
    "                               ExceptionState& exception_state) {\n",
    "  if (!ref_node) {\n",
    "    // FIXME: Generated bindings code never calls with null, and neither should\n",
    "    // other callers!\n",
    "    exception_state.ThrowTypeError(\"The node provided is null.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  // InvalidNodeTypeError: Raised if refNode or an ancestor of refNode is an\n",
    "  // Entity, Notation\n",
    "  // or DocumentType node.\n",
    "  for (Node* n = ref_node; n; n = n->parentNode()) {\n",
    "    switch (n->getNodeType()) {\n",
    "      case Node::kAttributeNode:\n",
    "      case Node::kCdataSectionNode:\n",
    "      case Node::kCommentNode:\n",
    "      case Node::kDocumentFragmentNode:\n",
    "      case Node::kDocumentNode:\n",
    "      case Node::kElementNode:\n",
    "      case Node::kProcessingInstructionNode:\n",
    "      case Node::kTextNode:\n",
    "        break;\n",
    "      case Node::kDocumentTypeNode:\n",
    "        exception_state.ThrowDOMException(\n",
    "            DOMExceptionCode::kInvalidNodeTypeError,\n",
    "            \"The node provided is of type '\" + ref_node->nodeName() + \"'.\");\n",
    "        return;\n",
    "    }\n",
    "  }\n",
    "\n",
    "  RangeUpdateScope scope(this);\n",
    "  if (owner_document_ != ref_node->GetDocument())\n",
    "    SetDocument(ref_node->GetDocument());\n",
    "\n",
    "  start_.SetToStartOfNode(*ref_node);\n",
    "  end_.SetToEndOfNode(*ref_node);\n",
    "}\n",
    "\n",
    "bool Range::selectNodeContents(Node* ref_node, Position& start, Position& end) {\n",
    "  if (!ref_node) {\n",
    "    return false;\n",
    "  }\n",
    "\n",
    "  for (Node* n = ref_node; n; n = n->parentNode()) {\n",
    "    switch (n->getNodeType()) {\n",
    "      case Node::kAttributeNode:\n",
    "      case Node::kCdataSectionNode:\n",
    "      case Node::kCommentNode:\n",
    "      case Node::kDocumentFragmentNode:\n",
    "      case Node::kDocumentNode:\n",
    "      case Node::kElementNode:\n",
    "      case Node::kProcessingInstructionNode:\n",
    "      case Node::kTextNode:\n",
    "        break;\n",
    "      case Node::kDocumentTypeNode:\n",
    "        return false;\n",
    "    }\n",
    "  }\n",
    "\n",
    "  RangeBoundaryPoint start_boundary_point(*ref_node);\n",
    "  start_boundary_point.SetToStartOfNode(*ref_node);\n",
    "  start = start_boundary_point.ToPosition();\n",
    "  RangeBoundaryPoint end_boundary_point(*ref_node);\n",
    "  end_boundary_point.SetToEndOfNode(*ref_node);\n",
    "  end = end_boundary_point.ToPosition();\n",
    "  return true;\n",
    "}\n",
    "\n",
    "// https://dom.spec.whatwg.org/#dom-range-surroundcontents\n",
    "void Range::surroundContents(Node* new_parent,\n",
    "                             ExceptionState& exception_state) {\n",
    "  if (!new_parent) {\n",
    "    // FIXME: Generated bindings code never calls with null, and neither should\n",
    "    // other callers!\n",
    "    exception_state.ThrowTypeError(\"The node provided is null.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  // 1. If a non-Text node is partially contained in the context object, then\n",
    "  // throw an InvalidStateError.\n",
    "  Node* start_non_text_container = &start_.Container();\n",
    "  if (start_non_text_container->getNodeType() == Node::kTextNode)\n",
    "    start_non_text_container = start_non_text_container->parentNode();\n",
    "  Node* end_non_text_container = &end_.Container();\n",
    "  if (end_non_text_container->getNodeType() == Node::kTextNode)\n",
    "    end_non_text_container = end_non_text_container->parentNode();\n",
    "  if (start_non_text_container != end_non_text_container) {\n",
    "    exception_state.ThrowDOMException(\n",
    "        DOMExceptionCode::kInvalidStateError,\n",
    "        \"The Range has partially selected a non-Text node.\");\n",
    "    return;\n",
    "  }\n",
    "\n",
    "  // 2. If newParent is a Document, DocumentType, or DocumentFragment node, then\n",
    "  // throw an InvalidNodeTypeError.\n",
    "  switch (new_parent->getNodeType()) {\n",
    "    case Node::kAttributeNode:\n",
    "    case Node::kDocumentFragmentNode:\n",
    "    case Node::kDocumentNode:\n",
    "    case Node::kDocumentTypeNode:\n",
    "      exception_state.ThrowDOMException(\n",
    "          DOMExceptionCode::kInvalidNodeTypeError,\n",
    "          \"The node provided is of type '\" + new_parent->nodeName() + \"'.\");\n",
    "      return;\n",
    "    case Node::kCdataSectionNode:\n",
    "    case Node::kCommentNode:\n",
    "    case Node::kElementNode:\n",
    "    case Node::kProcessingInstructionNode:\n",
    "    case Node::kTextNode:\n",
    "      break;\n",
    "  }\n",
    "\n",
    "  EventQueueScope scope;\n",
    "\n",
    "  // 3. Let fragment be the result of extracting context object.\n",
    "  DocumentFragment* fragment = extractContents(exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  // 4. If newParent has children, replace all with null within newParent.\n",
    "  while (Node* n = new_parent->firstChild()) {\n",
    "    To<ContainerNode>(new_parent)->RemoveChild(n, exception_state);\n",
    "    if (exception_state.HadException())\n",
    "      return;\n",
    "  }\n",
    "\n",
    "  // 5. If newParent has children, replace all with null within newParent.\n",
    "  insertNode(new_parent, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  // 6. Append fragment to newParent.\n",
    "  new_parent->appendChild(fragment, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  // 7. Select newParent within context object.\n",
    "  selectNode(new_parent, exception_state);\n",
    "}\n",
    "\n",
    "void Range::setStartBefore(Node* ref_node, ExceptionState& exception_state) {\n",
    "  CheckNodeBA(ref_node, exception_state);\n",
    "  if (exception_state.HadException())\n",
    "    return;\n",
    "\n",
    "  setStart(ref_node->parentNode(), ref_node->NodeIndex(), exception_state);\n",
    "}\n",
    "\n",
    "void Range::CheckExtractPrecondition(ExceptionState& exception_state) {\n",
    "  DCHECK(BoundaryPointsValid());\n",
    "\n",
    "  if (!commonAncestorContainer())\n",
    "    return;\n",
    "\n",
    "  Node* past_last = PastLastNode();\n",
    "  for (Node* n = FirstNode(); n != past_last; n = NodeTraversal::Next(*n)) {\n",
    "    if (n->IsDocumentTypeNode()) {\n",
    "      exception_state.ThrowDOMException(\n",
    "          DOMExceptionCode::kHierarchyRequestError,\n",
    "          \"The Range contains a doctype node.\");\n",
    "      return;\n",
    "    }\n",
    "  }\n",
    "}\n",
    "\n",
    "Node* Range::FirstNode() const {\n",
    "  return StartPosition().NodeAsRangeFirstNode();\n",
    "}\n",
    "\n",
    "Node* Range::PastLastNode() const {\n",
    "  return EndPosition().NodeAsRangePastLastNode();\n",
    "}\n",
    "\n",
    "gfx::Rect Range::BoundingBox() const {\n",
    "  return ComputeTextRect(EphemeralRange(this));\n",
    "}\n",
    "\n",
    "bool AreRangesEqual(const Range* a, const Range* b) {\n",
    "  if (a == b)\n",
    "    return true;\n",
    "  if (!a || !b)\n",
    "    return false;\n",
    "  return a->StartPosition() == b->StartPosition() &&\n",
    "         a->EndPosition() == b->EndPosition();\n",
    "}\n",
    "\n",
    "static inline void BoundaryNodeChildrenWillBeRemoved(\n",
    "    RangeBoundaryPoint& boundary,\n",
    "    ContainerNode& container) {\n",
    "  for (Node* node_to_be_removed = container.firstChild(); node_to_be_removed;\n",
    "       node_to_be_removed = node_to_be_removed->nextSibling()) {\n",
    "    if (boundary.ChildBefore() == node_to_be_removed) {\n",
    "      boundary.SetToStartOfNode(container);\n",
    "      return;\n",
    "    }\n",
    "\n",
    "    for (Node* n = &boundary.Container(); n; n = n->parentNode()) {\n",
    "      if (n == node_to_be_removed) {\n",
    "        boundary.SetToStartOfNode(container);\n",
    "        return;\n",
    "      }\n",
    "    }\n",
    "  }\n",
    "}\n",
    "\n",
    "static void BoundaryShadowNodeChildrenWillBeRemoved(\n",
    "    RangeBoundaryPoint& boundary,\n",
    "    ContainerNode& container) {\n",
    "  for (Node* node_to_be_removed = container.firstChild(); node_to_be_removed;\n",
    "       node_to_be_removed = node_to_be_removed->nextSibling()) {\n",
    "    for (Node* n = &boundary.Container(); n;\n",
    "         n = n->ParentOrShadowHostElement()) {\n",
    "      if (n == node_to_be_removed) {\n",
    "        boundary.SetToStartOfNode(container);\n",
    "        return;\n",
    "      }\n",
    "    }\n",
    "  }\n",
    "}\n",
    "\n",
    "void Range::NodeChildrenWillBeRemoved(ContainerNode& container) {\n",
    "  DCHECK_EQ(container.GetDocument(), owner_document_);\n",
    "  BoundaryNodeChildrenWillBeRemoved(start_, container);\n",
    "  BoundaryNodeChildrenWillBeRemoved(end_, container);\n",
    "}\n",
    "\n",
    "void Range::FixupRemovedChildrenAcrossShadowBoundary(ContainerNode& container) {\n",
    "  DCHECK_EQ(container.GetDocument(), owner_document_);\n",
    "  BoundaryShadowNodeChildrenWillBeRemoved(start_, container);\n",
    "  BoundaryShadowNodeChildrenWillBeRemoved(end_, container);\n",
    "}\n",
    "\n",
    "// Returns true if `boundary` was modified.\n",
    "static inline bool BoundaryNodeWillBeRemoved(RangeBoundaryPoint& boundary,\n",
    "                                             Node& node_to_be_removed) {\n",
    "  if (boundary.ChildBefore() == node_to_be_removed) {\n",
    "    boundary.ChildBeforeWillBeRemoved();\n",
    "    return true;\n",
    "  }\n",
    "\n",
    "  for (Node* n = &boundary.Container(); n; n = n->parentNode()) {\n",
    "    if (n == node_to_be_removed) {\n",
    "      boundary.SetToBeforeChild(node_to_be_removed);\n",
    "      return true;\n",
    "    }\n",
    "  }\n",
    "  return false;\n",
    "}\n",
    "\n",
    "static inline void BoundaryShadowNodeWillBeRemoved(RangeBoundaryPoint& boundary,\n",
    "                                                   Node& node_to_be_removed) {\n",
    "  DCHECK_NE(boundary.ChildBefore(), node_to_be_removed);\n",
    "\n",
    "  for (Node* node = &boundary.Container(); node;\n",
    "       node = node->ParentOrShadowHostElement()) {\n",
    "    if (node == node_to_be_removed) {\n",
    "      boundary.SetToBeforeChild(node_to_be_removed);\n",
    "      return;\n",
    "    }\n",
    "  }\n",
    "}\n",
    "\n",
    "void Range::NodeWillBeRemoved(Node& node) {\n",
    "  DCHECK_EQ(node.GetDocument(), owner_document_);\n",
    "  DCHECK_NE(node, owner_document_.Get());\n",
    "\n",
    "  // FIXME: Once DOMNodeRemovedFromDocument mutation event removed, we\n",
    "  // should change following if-statement to DCHECK(!node->parentNode).\n",
    "  if (!node.parentNode())\n",
    "    return;\n",
    "  const bool is_collapsed = collapsed();\n",
    "  const bool start_updated = BoundaryNodeWillBeRemoved(start_, node);\n",
    "  if (is_collapsed) {\n",
    "    if (start_updated)\n",
    "      end_ = start_;\n",
    "  } else {\n",
    "    BoundaryNodeWillBeRemoved(end_, node);\n",
    "  }\n",
    "}\n",
    "\n",
    "void Range::FixupRemovedNodeAcrossShadowBoundary(Node& node) {\n",
    "  BoundaryShadowNodeWillBeRemoved(start_, node);\n",
    "  BoundaryShadowNodeWillBeRemoved(end_, node);\n",
    "}\n",
    "\n",
    "static inline void BoundaryTextInserted(RangeBoundaryPoint& boundary,\n",
    "                                        const CharacterData& text,\n",
    "                                        unsigned offset,\n",
    "                                        unsigned length) {\n",
    "  if (boundary.Container() != &text)\n",
    "    return;\n",
    "  boundary.MarkValid();\n",
    "  unsigned boundary_offset = boundary.Offset();\n",
    "  if (offset >= boundary_offset)\n",
    "    return;\n",
    "  boundary.SetOffset(boundary_offset + length);\n",
    "}\n",
    "\n",
    "void Range::DidInsertText(const CharacterData& text,\n",
    "                          unsigned offset,\n",
    "                          unsigned length) {\n",
    "  DCHECK_EQ(text.GetDocument(), owner_document_);\n",
    "  BoundaryTextInserted(start_, text, offset, length);\n",
    "  BoundaryTextInserted(end_, text, offset, length);\n",
    "}\n",
    "\n",
    "static inline void BoundaryTextRemoved(RangeBoundaryPoint& boundary,\n",
    "                                       const CharacterData& text,\n",
    "                                       unsigned offset,\n",
    "                                       unsigned length) {\n",
    "  if (boundary.Container() != &text)\n",
    "    return;\n",
    "  boundary.MarkValid();\n",
    "  unsigned boundary_offset = boundary.Offset();\n",
    "  if (offset >= boundary_offset)\n",
    "    return;\n",
    "  if (offset + length >= boundary_offset)\n",
    "    boundary.SetOffset(offset);\n",
    "  else\n",
    "    boundary.SetOffset(boundary_offset - length);\n",
    "}\n",
    "\n",
    "void Range::DidRemoveText(const CharacterData& text,\n",
    "                          unsigned offset,\n",
    "                          unsigned length) {\n",
    "  DCHECK_EQ(text.GetDocument(), owner_document_);\n",
    "  BoundaryTextRemoved(start_, text, offset, length);\n",
    "  BoundaryTextRemoved(end_, text, offset, length);\n",
    "}\n",
    "\n",
    "static inline void BoundaryTextNodesMerged(RangeBoundaryPoint& boundary,\n",
    "                                           const NodeWithIndex& old_node,\n",
    "                                           unsigned offset) {\n",
    "  if (boundary.Container() == old_node.GetNode()) {\n",
    "    Node* const previous_sibling = old_node.GetNode().previousSibling();\n",
    "    DCHECK(previous_sibling);\n",
    "    boundary.Set(*previous_sibling, boundary.Offset() + offset, nullptr);\n",
    "  } else if (boundary.Container() == old_node.GetNode().parentNode() &&\n",
    "             boundary.Offset() == static_cast<unsigned>(old_node.Index())) {\n",
    "    Node* const previous_sibling = old_node.GetNode().previousSibling();\n",
    "    DCHECK(previous_sibling);\n",
    "    boundary.Set(*previous_sibling, offset, nullptr);\n",
    "  }\n",
    "}\n",
    "\n",
    "void Range::DidMergeTextNodes(const NodeWithIndex& old_node, unsigned offset) {\n",
    "  DCHECK_EQ(old_node.GetNode().GetDocument(), owner_document_);\n",
    "  DCHECK(old_node.GetNode().parentNode());\n",
    "  DCHECK(old_node.GetNode().IsTextNode());\n",
    "  DCHECK(old_node.GetNode().previousSibling());\n",
    "  DCHECK(old_node.GetNode().previousSibling()->IsTextNode());\n",
    "  BoundaryTextNodesMerged(start_, old_node, offset);\n",
    "  BoundaryTextNodesMerged(end_, old_node, offset);\n",
    "}\n",
    "\n",
    "void Range::UpdateOwnerDocumentIfNeeded() {\n",
    "  Document& new_document = start_.Container().GetDocument();\n",
    "  DCHECK_EQ(new_document, end_.Container().GetDocument());\n",
    "  if (new_document == owner_document_)\n",
    "    return;\n",
    "  owner_document_->DetachRange(this);\n",
    "  owner_document_ = &new_document;\n",
    "  owner_document_->AttachRange(this);\n",
    "}\n",
    "\n",
    "static inline void BoundaryTextNodeSplit(RangeBoundaryPoint& boundary,\n",
    "                                         const Text& old_node) {\n",
    "  unsigned boundary_offset = boundary.Offset();\n",
    "  if (boundary.ChildBefore() == &old_node) {\n",
    "    boundary.Set(boundary.Container(), boundary_offset + 1,\n",
    "                 old_node.nextSibling());\n",
    "  } else if (boundary.Container() == &old_node &&\n",
    "             boundary_offset > old_node.length()) {\n",
    "    Node* const next_sibling = old_node.nextSibling();\n",
    "    DCHECK(next_sibling);\n",
    "    boundary.Set(*next_sibling, boundary_offset - old_node.length(), nullptr);\n",
    "  }\n",
    "}\n",
    "\n",
    "void Range::DidSplitTextNode(const Text& old_node) {\n",
    "  DCHECK_EQ(old_node.GetDocument(), owner_document_);\n",
    "  DCHECK(old_node.parentNode());\n",
    "  DCHECK(old_node.nextSibling());\n",
    "  DCHECK(old_node.nextSibling()->IsTextNode());\n",
    "  BoundaryTextNodeSplit(start_, old_node);\n",
    "  BoundaryTextNodeSplit(end_, old_node);\n",
    "  DCHECK(BoundaryPointsValid());\n",
    "}\n",
    "\n",
    "void Range::expand(const String& unit, ExceptionState& exception_state) {\n",
    "  if (!StartPosition().IsConnected() || !EndPosition().IsConnected())\n",
    "    return;\n",
    "  owner_document_->UpdateStyleAndLayout(DocumentUpdateReason::kJavaScript);\n",
    "  VisiblePosition start = CreateVisiblePosition(StartPosition());\n",
    "  VisiblePosition end = CreateVisiblePosition(EndPosition());\n",
    "  if (unit == \"word\") {\n",
    "    start = CreateVisiblePosition(StartOfWordPosition(start.DeepEquivalent()));\n",
    "    end = CreateVisiblePosition(EndOfWordPosition(end.DeepEquivalent()));\n",
    "  } else if (unit == \"sentence\") {\n",
    "    start =\n",
    "        CreateVisiblePosition(StartOfSentencePosition(start.DeepEquivalent()));\n",
    "    end = CreateVisiblePosition(EndOfSentence(end.DeepEquivalent()));\n",
    "  } else if (unit == \"block\") {\n",
    "    start = StartOfParagraph(start);\n",
    "    end = EndOfParagraph(end);\n",
    "  } else if (unit == \"document\") {\n",
    "    start = CreateVisiblePosition(StartOfDocument(start.DeepEquivalent()));\n",
    "    end = EndOfDocument(end);\n",
    "  } else {\n",
    "    return;\n",
    "  }\n",
    "  setStart(start.DeepEquivalent().ComputeContainerNode(),\n",
    "           start.DeepEquivalent().ComputeOffsetInContainerNode(),\n",
    "           exception_state);\n",
    "  setEnd(end.DeepEquivalent().ComputeContainerNode(),\n",
    "         end.DeepEquivalent().ComputeOffsetInContainerNode(), exception_state);\n",
    "}\n",
    "\n",
    "DOMRectList* Range::getClientRects() const {\n",
    "  DisplayLockUtilities::ScopedForcedUpdate force_locks(\n",
    "      this, DisplayLockContext::ForcedPhase::kLayout);\n",
    "  owner_document_->UpdateStyleAndLayout(DocumentUpdateReason::kJavaScript);\n",
    "\n",
    "  Vector<gfx::QuadF> quads;\n",
    "  GetBorderAndTextQuads(quads);\n",
    "\n",
    "  return MakeGarbageCollected<DOMRectList>(quads);\n",
    "}\n",
    "\n",
    "DOMRect* Range::getBoundingClientRect() const {\n",
    "  return DOMRect::FromRectF(BoundingRect());\n",
    "}\n",
    "\n",
    "// TODO(editing-dev): We should make\n",
    "// |Document::AdjustQuadsForScrollAndAbsoluteZoom()| as const function\n",
    "// and takes |const LayoutObject&|.\n",
    "static Vector<gfx::QuadF> ComputeTextQuads(const Document& owner_document,\n",
    "                                           const LayoutText& layout_text,\n",
    "                                           unsigned start_offset,\n",
    "                                           unsigned end_offset) {\n",
    "  Vector<gfx::QuadF> text_quads;\n",
    "  layout_text.AbsoluteQuadsForRange(text_quads, start_offset, end_offset);\n",
    "  const_cast<Document&>(owner_document)\n",
    "      .AdjustQuadsForScrollAndAbsoluteZoom(\n",
    "          text_quads, const_cast<LayoutText&>(layout_text));\n",
    "  return text_quads;\n",
    "}\n",
    "\n",
    "// https://www.w3.org/TR/cssom-view-1/#dom-range-getclientrects\n",
    "void Range::GetBorderAndTextQuads(Vector<gfx::QuadF>& quads) const {\n",
    "  Node* start_container = &start_.Container();\n",
    "  Node* end_container = &end_.Container();\n",
    "  Node* stop_node = PastLastNode();\n",
    "\n",
    "  // Stores the elements selected by the range.\n",
    "  HeapHashSet<Member<const Node>> selected_elements;\n",
    "  for (Node* node = FirstNode(); node != stop_node;\n",
    "       node = NodeTraversal::Next(*node)) {\n",
    "    if (!node->IsElementNode())\n",
    "      continue;\n",
    "    auto* parent_node = node->parentNode();\n",
    "    if ((parent_node && selected_elements.Contains(parent_node)) ||\n",
    "        (!node->contains(start_container) && !node->contains(end_container))) {\n",
    "      DCHECK_LE(StartPosition(), Position::BeforeNode(*node));\n",
    "      DCHECK_GE(EndPosition(), Position::AfterNode(*node));\n",
    "      selected_elements.insert(node);\n",
    "    }\n",
    "  }\n",
    "\n",
    "  for (const Node* node = FirstNode(); node != stop_node;\n",
    "       node = NodeTraversal::Next(*node)) {\n",
    "    auto* element_node = DynamicTo<Element>(node);\n",
    "    if (element_node) {\n",
    "      if (!selected_elements.Contains(node) ||\n",
    "          selected_elements.Contains(node->parentNode()))\n",
    "        continue;\n",
    "      LayoutObject* const layout_object = element_node->GetLayoutObject();\n",
    "      if (!layout_object)\n",
    "        continue;\n",
    "      Vector<gfx::QuadF> element_quads;\n",
    "      layout_object->AbsoluteQuads(element_quads);\n",
    "      owner_document_->AdjustQuadsForScrollAndAbsoluteZoom(element_quads,\n",
    "                                                           *layout_object);\n",
    "\n",
    "      quads.AppendVector(element_quads);\n",
    "      continue;\n",
    "    }\n",
    "\n",
    "    auto* const text_node = DynamicTo<Text>(node);\n",
    "    if (!text_node)\n",
    "      continue;\n",
    "    LayoutText* const layout_text = text_node->GetLayoutObject();\n",
    "    if (!layout_text)\n",
    "      continue;\n",
    "\n",
    "    // TODO(editing-dev): Offset in |LayoutText| doesn't match to DOM offset\n",
    "    // when |text-transform| applied. We should map DOM offset to offset in\n",
    "    // |LayouText| for |start_offset| and |end_offset|.\n",
    "    const unsigned start_offset =\n",
    "        (node == start_container) ? start_.Offset() : 0;\n",
    "    const unsigned end_offset = (node == end_container)\n",
    "                                    ? end_.Offset()\n",
    "                                    : std::numeric_limits<unsigned>::max();\n",
    "    if (!layout_text->IsTextFragment()) {\n",
    "      quads.AppendVector(ComputeTextQuads(*owner_document_, *layout_text,\n",
    "                                          start_offset, end_offset));\n",
    "      continue;\n",
    "    }\n",
    "\n",
    "    // Handle ::first-letter\n",
    "    const auto& first_letter_part =\n",
    "        *To<LayoutTextFragment>(AssociatedLayoutObjectOf(*node, 0));\n",
    "    const bool overlaps_with_first_letter =\n",
    "        start_offset < first_letter_part.FragmentLength() ||\n",
    "        (start_offset == first_letter_part.FragmentLength() &&\n",
    "         end_offset == start_offset);\n",
    "    if (overlaps_with_first_letter) {\n",
    "      const unsigned start_in_first_letter = start_offset;\n",
    "      const unsigned end_in_first_letter =\n",
    "          std::min(end_offset, first_letter_part.FragmentLength());\n",
    "      quads.AppendVector(ComputeTextQuads(*owner_document_, first_letter_part,\n",
    "                                          start_in_first_letter,\n",
    "                                          end_in_first_letter));\n",
    "    }\n",
    "    const auto& remaining_part = *To<LayoutTextFragment>(layout_text);\n",
    "    if (end_offset > remaining_part.Start()) {\n",
    "      const unsigned start_in_remaining_part =\n",
    "          std::max(start_offset, remaining_part.Start()) -\n",
    "          remaining_part.Start();\n",
    "      // TODO(editing-dev): As we previously set |end_offset == UINT_MAX| as a\n",
    "      // hacky support for |text-transform|, we need the same hack here.\n",
    "      const unsigned end_in_remaining_part =\n",
    "          end_offset == UINT_MAX ? end_offset\n",
    "                                 : end_offset - remaining_part.Start();\n",
    "      quads.AppendVector(ComputeTextQuads(*owner_document_, remaining_part,\n",
    "                                          start_in_remaining_part,\n",
    "                                          end_in_remaining_part));\n",
    "    }\n",
    "  }\n",
    "}\n",
    "\n",
    "gfx::RectF Range::BoundingRect() const {\n",
    "  absl::optional<DisplayLockUtilities::ScopedForcedUpdate> force_locks;\n",
    "  if (!collapsed()) {\n",
    "    force_locks = DisplayLockUtilities::ScopedForcedUpdate(\n",
    "        this, DisplayLockContext::ForcedPhase::kLayout);\n",
    "  } else {\n",
    "    force_locks = DisplayLockUtilities::ScopedForcedUpdate(\n",
    "        FirstNode(), DisplayLockContext::ForcedPhase::kLayout);\n",
    "  }\n",
    "  owner_document_->UpdateStyleAndLayout(DocumentUpdateReason::kJavaScript);\n",
    "\n",
    "  Vector<gfx::QuadF> quads;\n",
    "  GetBorderAndTextQuads(quads);\n",
    "\n",
    "  gfx::RectF result;\n",
    "  for (const gfx::QuadF& quad : quads)\n",
    "    result.Union(quad.BoundingBox());  // Skips empty rects.\n",
    "\n",
    "  // If all rects are empty, return the first rect.\n",
    "  if (result.IsEmpty() && !quads.empty())\n",
    "    return quads.front().BoundingBox();\n",
    "\n",
    "  return result;\n",
    "}\n",
    "\n",
    "void Range::UpdateSelectionIfAddedToSelection() {\n",
    "  if (!OwnerDocument().GetFrame())\n",
    "    return;\n",
    "  FrameSelection& selection = OwnerDocument().GetFrame()->Selection();\n",
    "  if (this != selection.DocumentCachedRange())\n",
    "    return;\n",
    "  DCHECK(startContainer()->isConnected());\n",
    "  DCHECK(startContainer()->GetDocument() == OwnerDocument());\n",
    "  DCHECK(endContainer()->isConnected());\n",
    "  DCHECK(endContainer()->GetDocument() == OwnerDocument());\n",
    "  EventDispatchForbiddenScope no_events;\n",
    "  selection.SetSelection(SelectionInDOMTree::Builder()\n",
    "                             .Collapse(StartPosition())\n",
    "                             .Extend(EndPosition())\n",
    "                             .Build(),\n",
    "                         SetSelectionOptions::Builder()\n",
    "                             .SetShouldCloseTyping(true)\n",
    "                             .SetShouldClearTypingStyle(true)\n",
    "                             .SetDoNotSetFocus(true)\n",
    "                             .Build());\n",
    "  selection.CacheRangeOfDocument(this);\n",
    "}\n",
    "\n",
    "void Range::ScheduleVisualUpdateIfInRegisteredHighlight(Document& document) {\n",
    "  if (LocalDOMWindow* window = document.domWindow()) {\n",
    "    if (HighlightRegistry* highlight_registry =\n",
    "            window->Supplementable<LocalDOMWindow>::RequireSupplement<\n",
    "                HighlightRegistry>()) {\n",
    "      for (const auto& highlight_registry_map_entry :\n",
    "           highlight_registry->GetHighlights()) {\n",
    "        const auto& highlight = highlight_registry_map_entry->highlight;\n",
    "        if (highlight->Contains(this)) {\n",
    "          highlight_registry->ScheduleRepaint();\n",
    "          return;\n",
    "        }\n",
    "      }\n",
    "    }\n",
    "  }\n",
    "}\n",
    "\n",
    "void Range::RemoveFromSelectionIfInDifferentRoot(Document& old_document) {\n",
    "  if (!old_document.GetFrame())\n",
    "    return;\n",
    "  FrameSelection& selection = old_document.GetFrame()->Selection();\n",
    "  if (this != selection.DocumentCachedRange())\n",
    "    return;\n",
    "  if (OwnerDocument() == old_document && startContainer()->isConnected() &&\n",
    "      endContainer()->isConnected())\n",
    "    return;\n",
    "  selection.Clear();\n",
    "  selection.ClearDocumentCachedRange();\n",
    "}\n",
    "\n",
    "void Range::Trace(Visitor* visitor) const {\n",
    "  visitor->Trace(owner_document_);\n",
    "  visitor->Trace(start_);\n",
    "  visitor->Trace(end_);\n",
    "  ScriptWrappable::Trace(visitor);\n",
    "}\n",
    "\n",
    "}  // namespace blink\n",
    "\n",
    "#if DCHECK_IS_ON()\n",
    "\n",
    "void ShowTree(const blink::Range* range) {\n",
    "  if (range && range->BoundaryPointsValid()) {\n",
    "    LOG(INFO) << \"\\n\"\n",
    "              << range->startContainer()\n",
    "                     ->ToMarkedTreeString(range->startContainer(), \"S\",\n",
    "                                          range->endContainer(), \"E\")\n",
    "                     .Utf8()\n",
    "              << \"start offset: \" << range->startOffset()\n",
    "              << \", end offset: \" << range->endOffset();\n",
    "  } else {\n",
    "    LOG(INFO) << \"Cannot show tree if range is null, or if boundary points are \"\n",
    "                 \"invalid.\";\n",
    "  }\n",
    "}\n",
    "\n",
    "#endif\n",
    "\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "({' ': {'namespace': 'blink',\n",
       "   'functions': [{'name': 'scope', 'args': []},\n",
       "    {'name': 'original_end', 'args': ['end_']},\n",
       "    {'name': 'end_boundary_point', 'args': ['ref_node']},\n",
       "    {'name': 'force_locks',\n",
       "     'args': ['DisplayLockContext', 'ForcedPhase', 'kLayout']}]}},\n",
       " {'blink': []},\n",
       " {})"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "parse_cpp_code(cpp_code)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "import clang.cindex as clang\n",
    "\n",
    "def parse_cpp_code(code):\n",
    "    index = clang.Index.create()\n",
    "    tu = index.parse('file.cpp', args=['-x', 'c++', '-std=c++17'], unsaved_files=[('file.cpp', code)])\n",
    "\n",
    "    classes = {}\n",
    "    namespaces = {}\n",
    "\n",
    "    def visit_namespace(node, namespace_name):\n",
    "        namespaces[namespace_name] = []\n",
    "        for child in node.get_children():\n",
    "            if child.kind == clang.CursorKind.NAMESPACE:\n",
    "                visit_namespace(child, namespace_name + '::' + child.spelling)\n",
    "            elif child.kind == clang.CursorKind.CLASS_DECL:\n",
    "                visit_class(child, namespace_name)\n",
    "\n",
    "    def visit_class(node, namespace_name):\n",
    "        class_name = node.spelling\n",
    "        classes[class_name] = {'namespace': namespace_name, 'functions': [], 'fields': []}\n",
    "        for child in node.get_children():\n",
    "            if child.kind == clang.CursorKind.CXX_METHOD:\n",
    "                visit_function(child, class_name, namespace_name)\n",
    "            elif child.kind == clang.CursorKind.FIELD_DECL:\n",
    "                visit_field(child, class_name)\n",
    "\n",
    "    def visit_function(node, class_name, namespace_name):\n",
    "        function_name = node.spelling\n",
    "        function_args = []\n",
    "        for arg in node.get_children():\n",
    "            if arg.kind == clang.CursorKind.PARM_DECL:\n",
    "                arg_name = arg.spelling\n",
    "                arg_type = arg.type.spelling\n",
    "                function_args.append({'name': arg_name, 'type': arg_type})\n",
    "        classes[class_name]['functions'].append({'name': function_name, 'args': function_args})\n",
    "\n",
    "    def visit_field(node, class_name):\n",
    "        field_name = node.spelling\n",
    "        field_type = node.type.spelling\n",
    "        field_offset = node.offset\n",
    "        field_end_offset = field_offset + node.extent.end.offset - node.extent.start.offset\n",
    "        classes[class_name]['fields'].append({'name': field_name, 'type': field_type, 'offset': field_offset, 'end_offset': field_end_offset})\n",
    "\n",
    "    for node in tu.cursor.get_children():\n",
    "        if node.kind == clang.CursorKind.NAMESPACE:\n",
    "            visit_namespace(node, node.spelling)\n",
    "        elif node.kind == clang.CursorKind.CLASS_DECL:\n",
    "            visit_class(node, '')\n",
    "\n",
    "    return classes, namespaces"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Con"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "'Cursor' object has no attribute 'offset'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[18], line 1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m parse_cpp_code(cpp_code)\n",
      "Cell \u001b[0;32mIn[12], line 46\u001b[0m, in \u001b[0;36mparse_cpp_code\u001b[0;34m(code)\u001b[0m\n\u001b[1;32m     44\u001b[0m \u001b[39mfor\u001b[39;00m node \u001b[39min\u001b[39;00m tu\u001b[39m.\u001b[39mcursor\u001b[39m.\u001b[39mget_children():\n\u001b[1;32m     45\u001b[0m     \u001b[39mif\u001b[39;00m node\u001b[39m.\u001b[39mkind \u001b[39m==\u001b[39m clang\u001b[39m.\u001b[39mCursorKind\u001b[39m.\u001b[39mNAMESPACE:\n\u001b[0;32m---> 46\u001b[0m         visit_namespace(node, node\u001b[39m.\u001b[39;49mspelling)\n\u001b[1;32m     47\u001b[0m     \u001b[39melif\u001b[39;00m node\u001b[39m.\u001b[39mkind \u001b[39m==\u001b[39m clang\u001b[39m.\u001b[39mCursorKind\u001b[39m.\u001b[39mCLASS_DECL:\n\u001b[1;32m     48\u001b[0m         visit_class(node, \u001b[39m'\u001b[39m\u001b[39m'\u001b[39m)\n",
      "Cell \u001b[0;32mIn[12], line 16\u001b[0m, in \u001b[0;36mparse_cpp_code.<locals>.visit_namespace\u001b[0;34m(node, namespace_name)\u001b[0m\n\u001b[1;32m     14\u001b[0m     visit_namespace(child, namespace_name \u001b[39m+\u001b[39m \u001b[39m'\u001b[39m\u001b[39m::\u001b[39m\u001b[39m'\u001b[39m \u001b[39m+\u001b[39m child\u001b[39m.\u001b[39mspelling)\n\u001b[1;32m     15\u001b[0m \u001b[39melif\u001b[39;00m child\u001b[39m.\u001b[39mkind \u001b[39m==\u001b[39m clang\u001b[39m.\u001b[39mCursorKind\u001b[39m.\u001b[39mCLASS_DECL:\n\u001b[0;32m---> 16\u001b[0m     visit_class(child, namespace_name)\n",
      "Cell \u001b[0;32mIn[12], line 25\u001b[0m, in \u001b[0;36mparse_cpp_code.<locals>.visit_class\u001b[0;34m(node, namespace_name)\u001b[0m\n\u001b[1;32m     23\u001b[0m     visit_function(child, class_name, namespace_name)\n\u001b[1;32m     24\u001b[0m \u001b[39melif\u001b[39;00m child\u001b[39m.\u001b[39mkind \u001b[39m==\u001b[39m clang\u001b[39m.\u001b[39mCursorKind\u001b[39m.\u001b[39mFIELD_DECL:\n\u001b[0;32m---> 25\u001b[0m     visit_field(child, class_name)\n",
      "Cell \u001b[0;32mIn[12], line 40\u001b[0m, in \u001b[0;36mparse_cpp_code.<locals>.visit_field\u001b[0;34m(node, class_name)\u001b[0m\n\u001b[1;32m     38\u001b[0m field_name \u001b[39m=\u001b[39m node\u001b[39m.\u001b[39mspelling\n\u001b[1;32m     39\u001b[0m field_type \u001b[39m=\u001b[39m node\u001b[39m.\u001b[39mtype\u001b[39m.\u001b[39mspelling\n\u001b[0;32m---> 40\u001b[0m field_offset \u001b[39m=\u001b[39m node\u001b[39m.\u001b[39;49moffset\n\u001b[1;32m     41\u001b[0m field_end_offset \u001b[39m=\u001b[39m field_offset \u001b[39m+\u001b[39m node\u001b[39m.\u001b[39mextent\u001b[39m.\u001b[39mend\u001b[39m.\u001b[39moffset \u001b[39m-\u001b[39m node\u001b[39m.\u001b[39mextent\u001b[39m.\u001b[39mstart\u001b[39m.\u001b[39moffset\n\u001b[1;32m     42\u001b[0m classes[class_name][\u001b[39m'\u001b[39m\u001b[39mfields\u001b[39m\u001b[39m'\u001b[39m]\u001b[39m.\u001b[39mappend({\u001b[39m'\u001b[39m\u001b[39mname\u001b[39m\u001b[39m'\u001b[39m: field_name, \u001b[39m'\u001b[39m\u001b[39mtype\u001b[39m\u001b[39m'\u001b[39m: field_type, \u001b[39m'\u001b[39m\u001b[39moffset\u001b[39m\u001b[39m'\u001b[39m: field_offset, \u001b[39m'\u001b[39m\u001b[39mend_offset\u001b[39m\u001b[39m'\u001b[39m: field_end_offset})\n",
      "\u001b[0;31mAttributeError\u001b[0m: 'Cursor' object has no attribute 'offset'"
     ]
    }
   ],
   "source": [
    "parse_cpp_code(cpp_code)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
